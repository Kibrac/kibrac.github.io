[{"content":"附录 参考资料 版权信息 本文原载于 kibrac.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-01-13T16:49:44+08:00","permalink":"https://kibrac.github.io/p/cite-space/","title":"Cite Space"},{"content":"问题描述 在一批药品说明书中提取指定信息。PDF 文件的命名格式为：药品名称[数字编码]，说明书的内容结构示例如下：\n1 2 3 4 5 6 【药品名称】 xxxxxx 【适应症】 xxxxxx 【用法用量】 xxxxxx 需要提取的信息为【药品名称】以及【适应症】的相关内容。\n遇到的障碍 首先决定使用 Python 编写程序。\n事实上正常的思路应该是使用有关 PDF 编辑的 Python 库，但是不知道出于什么原因，我无法正常读取目标 PDF 文件，花费了一段时间仍然解决不了，所以决定先将 PDF 文件转换为 Word 文件进行处理。文章末尾会附上 PDF 批量转换为 Word 或其它格式的方法。\n最初的思路是：\n新建一个 Excel 表格，以 【药品】、【编码】、【药品名称】、【适应症】 为列标题。 【药品】 和 【编码】 利用 [] 作为读取断点然后分别写入即可。 读取 Word 文件中的内容，当遇到 【药物名称】 时，将其之后的内容全部提取出来写入 Excel 表格中 【药品名称】 这一列中，直到遇到 【适应症】 为止。 同理提取 【适应症】 的内容。 遍历文件夹中所有 PDF 文件。 但是事情远没有这么简单。\n转换得到的 Word 文件中，有一些本应作为标题的 【药品名称】 却位于页眉中，导致常规的读取代码无法读取到这部分内容，在尝试将页眉内容合并到正文中再进行处理但是无果的情况下，决定采取一种曲线救国的方法：\n利用下一板块的内容【适应症】来反向定位【药物名称】所在的位置，也就是将【适应症】之前的内容全部视为药物名称，然后为了防止把本就位于正文的【药物名称】这个标题也写入到单元格内，再手动在代码中把这个标题的内容删掉。\n代码编写 综上，借助 ChatGPT 得到了以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from docx import Document from openpyxl import Workbook import os import re def extract_content(docx_path): doc = Document(docx_path) content = {\u0026#34;【药品名称】\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;【适应症】\u0026#34;: \u0026#34;\u0026#34;} is_drug_name = True # 用于标记是否正在处理药品名称 for paragraph in doc.paragraphs: if paragraph.text.startswith(\u0026#34;【适应症】\u0026#34;): # 切换到处理适应症的模式 is_drug_name = False elif paragraph.text.startswith(\u0026#34;【用法用量】\u0026#34;): # 遇到用法用量结束处理 break elif is_drug_name: # 如果在处理药品名称时，且当前段落不是标题，则将其内容视为药品名称，忽略标题本身 if not paragraph.text.startswith(\u0026#34;【药品名称】\u0026#34;): content[\u0026#34;【药品名称】\u0026#34;] += paragraph.text + \u0026#34;\\n\u0026#34; else: # 将适应症之后、用法用量之前的内容视为适应症 content[\u0026#34;【适应症】\u0026#34;] += paragraph.text + \u0026#34;\\n\u0026#34; return content def extract_file_info(file_path): # 提取文件名中的药品和编码信息 file_name = os.path.basename(file_path) match = re.match(r\u0026#34;(.+)\\[([^\\[\\]]+)\\].docx\u0026#34;, file_name) if match: return match.group(1), match.group(2) return None, None def write_to_excel(excel_path, folder_path): # 创建新的 Workbook wb = Workbook() ws = wb.active # 写入列标题 ws.append([\u0026#34;【药品】\u0026#34;, \u0026#34;【编码】\u0026#34;, \u0026#34;【药品名称】\u0026#34;, \u0026#34;【适应症】\u0026#34;]) # 遍历文件夹中的所有文件 for filename in os.listdir(folder_path): if filename.endswith(\u0026#34;.docx\u0026#34;): docx_file = os.path.join(folder_path, filename) # 提取文件名中的药品和编码信息 drug_name, code = extract_file_info(docx_file) # 提取指定标签的内容 content = extract_content(docx_file) # 将每个文件的信息写入 Excel 表格的新行 ws.append([drug_name, code, content[\u0026#34;【药品名称】\u0026#34;].strip(), content[\u0026#34;【适应症】\u0026#34;].strip()]) # 保存 Excel 文件 wb.save(excel_path) print(\u0026#34;Success\u0026#34;) # 指定包含 docx 文件的文件夹路径 folder_path = \u0026#34;folder_path\u0026#34; # 指定输出的 excel 文件路径 excel_file = \u0026#34;excel_file.xlsx\u0026#34; # 将文件夹中所有文件的信息写入 Excel 表格 write_to_excel(excel_file, folder_path) 至此，批量提取 PDF 文件中的指定内容并写入到表格中的任务就算完成了，这里附上利用 Acrobat DC 批量转换 PDF 文件的方法——首先需要在 Windows 电脑上安装了Acrobat DC，然后编写一个 vbs 脚本。脚本的工作原理相当于电脑自动使用鼠标进行一系列按钮的点击并循环。\n附：PDF 批量转换 新建一个文本文件，然后写入以下代码，保存文件修改后缀为 .vbs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 Function SaveAs(OriginalFile,Extension) Dim ExportFormat Dim acroApp NewFileName = Replace(OriginalFile,\u0026#34;.pdf\u0026#34;,\u0026#34;.docx\u0026#34;) Set acroApp = CreateObject(\u0026#34;AcroExch.App\u0026#34;) Dim acroAVDoc Set acroAVDoc = CreateObject(\u0026#34;AcroExch.AVDoc\u0026#34;) Call acroAVDoc.Open(OriginalFile,\u0026#34;\u0026#34;) If acroAVDoc Is Nothing Then Exit Function End If Dim acroPDDoc Set acroPDDoc = acroAVDoc.GetPDDoc Dim jso Set jso = acroPDDoc.GetJSObject Select Case LCase(extension) Case \u0026#34;eps\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.eps\u0026#34; Case \u0026#34;html\u0026#34;, \u0026#34;htm\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.html\u0026#34; Case \u0026#34;jpeg\u0026#34;, \u0026#34;jpg\u0026#34;, \u0026#34;jpe\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.jpeg\u0026#34; Case \u0026#34;jpf\u0026#34;, \u0026#34;jpx\u0026#34;, \u0026#34;jp2\u0026#34;, \u0026#34;j2k\u0026#34;, \u0026#34;j2c\u0026#34;, \u0026#34;jpc\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.jp2k\u0026#34; Case \u0026#34;docx\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.docx\u0026#34; Case \u0026#34;doc\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.doc\u0026#34; Case \u0026#34;png\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.png\u0026#34; Case \u0026#34;ps\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.ps\u0026#34; Case \u0026#34;rft\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.rft\u0026#34; Case \u0026#34;xlsx\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.xlsx\u0026#34; Case \u0026#34;xls\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.spreadsheet\u0026#34; Case \u0026#34;txt\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.accesstext\u0026#34; Case \u0026#34;tiff\u0026#34;, \u0026#34;tif\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.tiff\u0026#34; Case \u0026#34;xml\u0026#34;: ExportFormat = \u0026#34;com.adobe.acrobat.xml-1-00\u0026#34; Case Else: ExportFormat = \u0026#34;Wrong Input\u0026#34; End Select If ExportFormat \u0026lt;\u0026gt; \u0026#34;Wrong Input\u0026#34; Then Call jso.SaveAs(NewFileName, ExportFormat) SaveAs = True Else SaveAs = False End If \u0026#39;Release the objects. acroPDDoc.Close acroAVDoc.Close True acroApp.Exit Set jso = Nothing Set acroPDDoc = Nothing Set acroAVDoc = Nothing Set acroApp = Nothing End Function Sub DoBatchConvert(Dir,Extension) set objFSO = CreateObject(\u0026#34;Scripting.FileSystemObject\u0026#34;) objStartFolder = \u0026#34;.\u0026#34; Set objFolder = objFSO.GetFolder(objStartFolder) Set colFiles = objFolder.Files For Each objFile in colFiles If objFSO.GetExtensionName(objFile.Name) = \u0026#34;pdf\u0026#34; Then Call SaveAs(objFile.Path,Extension) End If Next End Sub DoBatchConvert \u0026#34;.\u0026#34;,\u0026#34;docx\u0026#34; 将该文件放入包含你想要批量转换的 PDF 文件的文件夹中，双击该 vbs 文件即可开始转换。转换后的文件全部保存在该文件夹中，如果要导出为其它格式，则把该 vbs 文件最后一行的\u0026quot;docx\u0026quot;改为你想要的格式。\n附录 参考资料 PDF 批量转换为 WORD 或其它格式\n版权信息 本文原载于 kibrac.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-01-13T10:47:55+08:00","permalink":"https://kibrac.github.io/p/pdf-batch-extraction/","title":"批量提取 PDF 文件中的指定信息存储在 Excel 表格中"},{"content":"思路 将大语言模型通过编写宏封装为函数，进而对 Excel 表格中的内容进行批量翻译。\n工具准备 演示使用的软件是 Microsoft Office Home and Student 2019 中的 Excel，另外还需要一个可用的大语言模型的 API key，此处以智谱 AI 的 GLM-4 为例。关于 API key 的获取有很多参考教程这里不进行赘述。\n代码编写 打开 Excel 中的 VBA 编辑器。 我们可以通过以下方式找到 VBA 编辑器。 按下快捷键 Alt+F11 直接打开 从菜单栏中的“开发工具”中选择 Visual Basic 如果你的菜单中没有“开发工具”选项，可以通过“文件”\u0026gt;“选项”\u0026gt;“自定义功能区”中勾选“开发工具”来添加它 插入新模块 在编辑器菜单中选择 插入 - 模块，添加一个新的模块。\n编写 VBA 代码。 以下代码是根据参考教程中的代码以及智谱 AI 提供的接口文档进行改写得到。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 Function zhipu(prompt As String) As String \u0026#39; 声明变量 Dim url As String, apiKey As String Dim response As Object, json As String, data As String Dim ws As Worksheet \u0026#39; 设置指向第一个工作表 Set ws = ThisWorkbook.Sheets(1) \u0026#39; 从工作表的B1单元格获取API密钥 apiKey = ws.Range(\u0026#34;B1\u0026#34;).Value \u0026#39; 检查API密钥是否为空 If apiKey = \u0026#34;\u0026#34; Then MsgBox \u0026#34;请在Sheet1的B1单元格中填写apiKey\u0026#34;, vbExclamation zhipu = \u0026#34;Error: API key is missing\u0026#34; Exit Function End If \u0026#39; 设置请求URL url = \u0026#34;https://open.bigmodel.cn/api/paas/v4/chat/completions\u0026#34; \u0026#39; 替换特殊字符，并构建要发送的JSON数据 Dim cleanPrompt As String cleanPrompt = Replace(prompt, \u0026#34;\u0026#34;\u0026#34;\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;\u0026#34;) \u0026#39; 转义双引号 cleanPrompt = Replace(cleanPrompt, vbCrLf, \u0026#34;\\n\u0026#34;) \u0026#39; 替换Excel中的换行符为JSON中的\\n cleanPrompt = Replace(cleanPrompt, Chr(13), \u0026#34;\\n\u0026#34;) \u0026#39; 替换回车符 cleanPrompt = Replace(cleanPrompt, Chr(10), \u0026#34;\\n\u0026#34;) \u0026#39; 替换换行符 data = \u0026#34;{\u0026#34;\u0026#34;model\u0026#34;\u0026#34;:\u0026#34;\u0026#34;glm-4\u0026#34;\u0026#34;,\u0026#34; \u0026amp; _ \u0026#34;\u0026#34;\u0026#34;messages\u0026#34;\u0026#34;:[{\u0026#34;\u0026#34;role\u0026#34;\u0026#34;:\u0026#34;\u0026#34;user\u0026#34;\u0026#34;,\u0026#34;\u0026#34;content\u0026#34;\u0026#34;:\u0026#34;\u0026#34;\u0026#34; \u0026amp; cleanPrompt \u0026amp; \u0026#34;\u0026#34;\u0026#34;}],\u0026#34; \u0026amp; _ \u0026#34;\u0026#34;\u0026#34;temperature\u0026#34;\u0026#34;:0.5}\u0026#34; \u0026#39; 初始化HTTP请求对象，并设置请求方法、URL和同步标志 Set response = CreateObject(\u0026#34;MSXML2.ServerXMLHTTP\u0026#34;) response.Open \u0026#34;POST\u0026#34;, url, False \u0026#39; 设置请求头 response.setRequestHeader \u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34; response.setRequestHeader \u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; \u0026amp; apiKey \u0026#39; 发送请求和数据 response.Send data \u0026#39; 获取响应文本 json = response.responseText \u0026#39; 解析JSON响应 Dim jsonObject As Object Set jsonObject = JsonConverter.ParseJson(json) \u0026#39; 从解析的JSON中提取所需内容并返回 On Error Resume Next zhipu = jsonObject(\u0026#34;choices\u0026#34;)(1)(\u0026#34;message\u0026#34;)(\u0026#34;content\u0026#34;) If Err.Number \u0026lt;\u0026gt; 0 Then zhipu = \u0026#34;Error parsing response: \u0026#34; \u0026amp; json End If On Error GoTo 0 End Function 导入 Json 解析依赖 下载用于 JSON 解析的依赖。下载地址\n在编辑器菜单中选择 文件 - 导入文件 将下载得到的文件导入到项目中。\n设置引用 在 VBA 编辑器中，选择 工具 - 引用，选中 Microsoft Scripting Runtime。\n填入 API key 根据之前编写的代码在第一个工作表的 B1 单元格中填入 API key。\n使用编写的函数 像在 Excel 中调用其他函数一样，在任意一个单元格中输入 =zhipu(\u0026quot;你好\u0026quot;),正常情况下会停顿一下然后自动填入大语言模型返回的结果。\n到此，已经实现了在 Excel 中接入大语言模型。\n批量翻译 首先需要生成提交给大语言模型的 prompt，这里可以使用 CONCATENATE 函数。\nCONCATENATE 函数 是 CONCAT 函数的老版本，用来将不同单元格里的文本等内容组合起来，但不会出现间隔符号的函数。\n这里假设 A2 单元格为需要翻译的内容，我们可以在一个新的单元格例如 B2 中输入 =CONCATENATE(\u0026quot;请将以下内容翻译为中文：\u0026quot;, A2) 回车，在 B2 中生成发送给大语言模型的 prompt。\n另外再选择一个新的单元格例如 C2 输入 =zhipu(B2),回车，稍等片刻，得到翻译结果。\n注意事项 本文中使用的 API key 来源自官方开发者平台，而中转 API key 未进行过测试，并不清楚能否正常运行。（从各官方网站获取 API key，可以参考其提供的接口文档来编写代码，更为简单易用） 在保存文件时，选择支持宏的 xlsm 格式。 附录 参考资料 爽，效率再提升 10 倍，你肯定没用过的 Kimi 高阶用法\n版权信息 本文原载于 kibrac.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-01-13T10:47:31+08:00","permalink":"https://kibrac.github.io/p/llm-in-excel/","title":"在 Excel 中接入大语言模型进行批量翻译"},{"content":"初始建站 利用 Hugo 搭配 GitHub pages 建立一个免费的个人博客网上已有诸多教程，这里仅推荐一个笔者所借鉴的从搭建直到完成 GitHub 自动部署的教程： 从零搭建个人博客并配置自动部署：Hugo搭配Github Pages\nStack 主题 初步配置 根据以下教程即可完成初步对主题文件的初步配置： 建站技术 | 使用 Hugo + Stack 简单搭建一个博客\n到此，你的博客已经可以开始投入使用了。\n插播一条 笔者以为用输出倒逼输入是极为有效的学习方式，因此不必等到万事俱备（事实上可能压根就等不到），就已经可以进行你的记录了，这也是本篇文章进行持续更新的原因。\n附录 版权信息 本文原载于 kibrac.github.io，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-01-12T15:48:34+08:00","permalink":"https://kibrac.github.io/p/hugo-stack-customize/","title":"Hugo 博客主题 Stack 配置——持续更新"}]